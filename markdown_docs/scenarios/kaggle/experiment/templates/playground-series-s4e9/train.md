## FunctionDef compute_rmse(y_true, y_pred)
**compute_rmse**: This function calculates the Root Mean Square Error (RMSE) between true values and predicted values, which is a common metric used to measure the accuracy of regression models.

parameters:
路 y_true: An array-like structure containing the actual target values from the dataset.
路 y_pred: An array-like structure containing the predicted target values generated by a regression model.

Code Description: The function begins by computing the Mean Squared Error (MSE) using the `mean_squared_error` function, which takes two arguments: the true values (`y_true`) and the predicted values (`y_pred`). MSE is calculated as the average of the squares of the differences between corresponding elements in `y_true` and `y_pred`. After calculating the MSE, the function computes the square root of this value to obtain the RMSE. The RMSE provides an indication of how far off the predictions are from the actual values on average, with a lower RMSE indicating better model performance.

Note: It is important that both `y_true` and `y_pred` have the same dimensions and contain numerical data for accurate computation. Additionally, users should ensure they have imported necessary libraries such as numpy (`np`) and sklearn.metrics (specifically `mean_squared_error`) before using this function.

Output Example: If `y_true = [3, -0.5, 2, 7]` and `y_pred = [2.5, 0.0, 2, 8]`, the function would compute an RMSE of approximately `0.6124`. This value represents the average magnitude of the errors in a set of predictions, without considering their direction.
## FunctionDef import_module_from_path(module_name, module_path)
**import_module_from_path**: This function dynamically imports a Python module from a specified file path, allowing for flexible module loading at runtime.

parameters:
路 module_name: A string representing the name of the module to be imported.
路 module_path: A string representing the file system path to the Python file containing the module.

Code Description: The function utilizes the `importlib.util` module, which provides utilities for importing modules. It starts by creating a module specification using `spec_from_file_location`, where it takes the name of the module and its file location as arguments. This specification contains all necessary information about how to load the module. Next, it creates a new module based on this specification with `module_from_spec`. Finally, it executes the module in its own namespace using `exec_module` from the loader attached to the specification, effectively running the code within the module file and making its contents available as a Python object.

Note: This function is particularly useful when you need to load modules dynamically at runtime, such as when the module's location is determined programmatically or when dealing with plugins. It allows for more flexible program design by enabling the inclusion of external scripts without hardcoding their paths into the main application.

Output Example: If there were a Python file located at '/path/to/module.py' containing a function `greet` that prints "Hello, world!", calling `import_module_from_path('my_module', '/path/to/module.py')` would return a module object. You could then access and use the `greet` function from this returned module object like so: `module.greet()`, which would print "Hello, world!".
